<!-- Index.cshtml -->
@{
ViewData["Title"] = "Chat";
}
@section Styles
{
    <link rel="stylesheet" href="~/css/page/chat.css" asp-append-version="true" />
}

@Html.AntiForgeryToken()

<div id="autoVerifyScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 9999; display: flex; align-items: center; justify-content: center;">
    <div class="text-center">
        <div class="spinner-border text-primary mb-3" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <h5 class="fw-bold mb-2">Đang xác thực...</h5>
        <p class="text-muted" id="autoVerifyMessage">Vui lòng đợi</p>
    </div>
</div>

<div class="container-fluid vh-100 d-flex flex-column p-0">
    <div class="row g-0 flex-grow-1">
        <div class="col-md-4 col-lg-3 border-end bg-white d-flex flex-column">
            <div class="p-3 border-bottom">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h4 class="mb-0 fw-bold">Chat</h4>
                    <button class="btn btn-sm btn-outline-danger" onclick="logoutFromChat()" title="Đăng xuất khỏi chat">
                        <i class="bi bi-lock-fill"></i>
                    </button>
                </div>

                <div class="input-group search-box">
                    <span class="input-group-text bg-light border-0">
                        <i class="bi bi-search"></i>
                    </span>
                    <input type="text"
                           id="searchUserInput"
                           class="form-control bg-light border-0"
                           placeholder="Tìm kiếm trong Messenger"
                           autocomplete="off" />
                    <button class="btn btn-light border-0" type="button" id="clearSearch" style="display: none;">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            </div>

            <div id="searchResults" class="flex-grow-1 overflow-auto" style="display: none;">
                <div class="p-2">
                    <div class="d-flex justify-content-between align-items-center px-2 mb-2">
                        <h6 class="text-muted mb-0 small">Kết quả tìm kiếm</h6>
                        <span id="searchCount" class="badge bg-primary rounded-pill">0</span>
                    </div>
                    <div id="searchResultsList"></div>
                </div>
            </div>

            <div id="conversationList" class="flex-grow-1 overflow-auto">
                <div id="contactsListContainer" class="p-2">
                    <div class="text-center text-muted py-5" id="emptyContactsState">
                        <i class="bi bi-chat-dots" style="font-size: 3rem; opacity: 0.3;"></i>
                        <p class="mt-2 mb-0 small">Chưa có tin nhắn nào</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-8 col-lg-9 d-flex flex-column bg-light">
            <div id="welcomeScreen" class="flex-grow-1 d-flex align-items-center justify-content-center">
                <div class="text-center">
                </div>
            </div>

            <div id="chatWindow" style="display: none;" class="d-flex flex-column flex-grow-1 bg-white">
                <div class="chat-header p-3 border-bottom bg-white">
                    <div class="d-flex align-items-center">
                        <div class="avatar-chat me-3">
                            <div class="avatar-circle-chat" id="headerAvatar">
                                <i class="bi bi-person-fill"></i>
                            </div>
                        </div>
                        <div class="flex-grow-1">
                            <h6 class="mb-0 fw-semibold" id="chatDisplayName">Display Name</h6>
                            <small class="text-muted" id="chatUsername"></small>
                        </div>
                    </div>
                </div>

                <div id="messagesArea" class="flex-grow-1 overflow-auto p-3">
                    <div class="text-center text-muted py-4">
                        <div class="avatar-large mb-3">
                            <i class="bi bi-person-fill"></i>
                        </div>
                        <h5 class="fw-semibold" id="welcomeName">Tên người dùng</h5>
                        <p class="text-muted small">
                            <i class="bi bi-lock-fill"></i> Tin nhắn được mã hóa đầu cuối
                        </p>
                    </div>
                </div>

                <div class="message-input-area p-3 border-top bg-white">
                    <form id="messageForm">
                        <div id="filePreview" class="d-none mb-2">
                            <div class="card bg-light border-0">
                                <div class="card-body p-2">
                                    <div class="d-flex align-items-center">
                                        <i id="fileIcon" class="bi bi-file-earmark fs-3 text-primary me-2"></i>
                                        <div class="flex-grow-1">
                                            <div id="fileName" class="small fw-semibold"></div>
                                            <div id="fileSize" class="text-muted" style="font-size: 0.75rem;"></div>
                                        </div>
                                        <button type="button" class="btn btn-sm btn-link text-danger" id="removeFileBtn">
                                            <i class="bi bi-x-lg"></i>
                                        </button>
                                    </div>
                                    <div id="uploadProgress" class="progress mt-3 mb-2" style="height: 12px; display: none; border-radius: 20px; background-color: #eaecf0; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);">
                                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                             role="progressbar" 
                                             style="width: 0%; border-radius: 20px; background: linear-gradient(90deg, #0084ff, #00c6ff); box-shadow: 0 2px 5px rgba(0, 132, 255, 0.4);">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="d-flex align-items-center gap-2">
                            <button type="button" class="btn btn-light rounded-circle p-2" id="attachFileBtn">
                                <i class="bi bi-paperclip text-primary fs-5"></i>
                            </button>
                            <input type="file" id="fileInput" class="d-none" multiple
                                   accept="image/*,video/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.zip,.rar" />

                            <textarea type="text" id="messageInput"
                                   class="form-control rounded-pill border-0 bg-light px-4 py-2"
                                   placeholder="Aa" autocomplete="off" disabled></textarea>

                            <button type="submit" class="btn btn-primary rounded-circle p-2" id="sendBtn" disabled>
                                <i class="bi bi-send-fill"></i>
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="loadingModal" data-bs-backdrop="static" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-sm">
        <div class="modal-content border-0 shadow">
            <div class="modal-body text-center py-4">
                <div class="spinner-border text-primary mb-3" role="status"></div>
                <p class="mb-0 fw-semibold" id="loadingMessage">Đang tải...</p>
            </div>
        </div>
    </div>
</div>

@section Scripts {
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
<script src="js/site.js"></script>
<script src="js/aesHelper.js"></script>
<script src="lib/signalr"></script>
<script>
    // ===== GLOBAL VARIABLES =====
    let currentConversationId = null;
    let currentRecipientId = null;
    let currentRecipientPublicKey = null;
    let currentUserId = null;
    let searchTimeout = null;
    let myPin = null;
    let conversationKeysCache = new Map();
    let myPrivateKeyEncrypted = null;
    let typingTimeout = null;
    let connection = null;
    // let selectedFile = null;
    let selectedFiles = [];
    // pagination
    let oldestMessageId = null;
    let isLoadingHistory = false;
    let isAllLoaded = false;

    const FALLBACK_IMAGE = '/images/file-error.png'; // Đường dẫn đến PNG fallback
    
    const currentUsername = '@User.Identity!.Name';

    // ===== PIN & AUTH =====
    function generateRandomKey(length = 32) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@@#$%^&*()';
        let result = '';
        const randomValues = new Uint32Array(length);
        window.crypto.getRandomValues(randomValues);
        for (let i = 0; i < length; i++) {
            result += chars[randomValues[i] % chars.length];
        }
        return result;
    }

    async function getConversationKey(convId) {
        if (conversationKeysCache.has(convId)) {
            return conversationKeysCache.get(convId);
        }

        try {
            // 2. Gọi API GetConvKey (API mới bạn vừa tạo ở Controller)
            const resp = await fetch(`@Url.Action("GetConversationKey", "Chat")?conversationId=${convId}`);

            if (resp.ok) {
                const data = await resp.json();
                // data.encryptedKey là AES Key được mã hóa bằng RSA Public Key của MÌNH

                // 3. Lấy Private Key của mình (đã được PIN bảo vệ) để giải mã
                const myPrivateKeyEnc = await getMyPrivateKey();
                const myPin = getMyPin();

                if (!myPrivateKeyEnc || !myPin) return null;

                // Giải mã Private Key bằng PIN
                const decryptedBytes = CryptoJS.AES.decrypt(myPrivateKeyEnc, myPin);
                let myPrivateKey;
                try {
                    myPrivateKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                } catch (e) { return null; }

                if (!myPrivateKey){
                    console.error("GetConversationKey: private Key null!");
                    return null;
                }

                // 4. Dùng Private Key giải mã ra Conversation Key (AES Key)
                const decrypt = new JSEncrypt();
                decrypt.setPrivateKey(myPrivateKey);
                const plainConvKey = decrypt.decrypt(data.encryptedKey);

                if (plainConvKey) {
                    // Lưu vào cache để dùng lại
                    conversationKeysCache.set(convId, plainConvKey);
                    return plainConvKey;
                }
            }
        } catch (e) {
            console.error("Lỗi khi lấy Conversation Key:", e);
        }
        return null;
    }
    
    function getToken() {
        return document.querySelector('input[name="__RequestVerificationToken"]')?.value || '';
    }

    async function autoVerifyPin() {
        const storageKey = `pinCode_${currentUsername}`;
        const savedPin = StorageHelper.get(storageKey);
        console.log("AutoVerifyPin Called!");
        if (!savedPin) {
            document.getElementById('autoVerifyMessage').textContent = 'Chưa có mã PIN...';
            setTimeout(() => window.location.href = '@Url.Action("VerifyPinCode", "Chat")', 1000);
            return false;
        }
        document.getElementById('autoVerifyMessage').textContent = 'Đang xác thực...';
        try {
            const hashedPin = CryptoJS.SHA256(savedPin).toString();
            const response = await fetch('@Url.Action("VerifyPinCodeAuto", "Chat")', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'RequestVerificationToken': getToken() },
                body: JSON.stringify(hashedPin)
            });
            if (response.ok && (await response.json()).success) {
                myPin = savedPin;
                setTimeout(() => document.getElementById('autoVerifyScreen').style.display = 'none', 500);
                return true;
            }
            else{
                StorageHelper.remove(storageKey);
            }
        } catch (e) {}
        document.getElementById('autoVerifyMessage').textContent = 'Lỗi xác thực...';
        setTimeout(() => window.location.href = '@Url.Action("VerifyPinCode", "Chat")', 1500);
        return false;
    }

    function getMyPin() { return myPin; }

    async function getMyPrivateKey() {
        if (myPrivateKeyEncrypted) return myPrivateKeyEncrypted;
        try {
            const resp = await fetch('@Url.Action("GetMyPrivateKey", "Chat")');
            if (resp.ok) return myPrivateKeyEncrypted = (await resp.json()).privateKeyEncrypted;
        } catch (e) {}
        return null;
    }

    async function loadCurrentUserInfo() {
        try {
            const resp = await fetch('@Url.Action("GetCurrentUserInfo", "Chat")');
            if (resp.ok) {
                currentUserId = (await resp.json()).userId;
                return true;
            }
        } catch (e) {}
        return false;
    }

    // ===== UI HELPERS =====
    let loadingModalInstance = null;
    function showLoading(msg = 'Đang tải...') {
        const el = document.getElementById('loadingModal');
        document.getElementById('loadingMessage').textContent = msg;
        if (!loadingModalInstance) loadingModalInstance = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false });
        loadingModalInstance.show();
    }
    function hideLoading() {
        if (loadingModalInstance) loadingModalInstance.hide();
        setTimeout(() => {
            const modalEl = document.getElementById('loadingModal');
            if(modalEl) {
                modalEl.classList.remove('show');
                modalEl.style.display = 'none';
                modalEl.removeAttribute('aria-hidden');
                modalEl.removeAttribute('role');
            }
            document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('padding-right');
            document.body.style.removeProperty('overflow');
        }, 300);
    }

    function scrollToBottom(smooth = true) {
        const area = document.getElementById('messagesArea');
        if (!area) return;

        // Auto-scroll logic: only if near bottom or forced
        const isNearBottom = area.scrollHeight - area.scrollTop - area.clientHeight < 150;

        if (isNearBottom || !smooth) {
            area.scrollTo({
                top: area.scrollHeight,
                behavior: smooth ? 'smooth' : 'auto'
            });
        }
    }

    // ===== RECENT CONTACTS LOGIC (danh sách người đã nhắn tin bên trái) =====
    async function loadRecentContacts() {
        try {
            const response = await fetch('@Url.Action("GetRecentContacts", "Chat")');
            if (!response.ok) return;
            const contacts = await response.json();
            displayContacts(contacts);
        } catch (error) { console.error("Error loading contacts:", error); }
    }

    function displayContacts(contacts) {
        const container = document.getElementById('contactsListContainer');
        if (!container) return;

        // Sort: Mới nhất lên đầu
        contacts.sort((a, b) => new Date(b.lastSentAt) - new Date(a.lastSentAt));

        if (contacts.length === 0) {
            container.innerHTML = `
                <div class="text-center text-muted py-5" id="emptyContactsState">
                    <i class="bi bi-chat-dots" style="font-size: 3rem; opacity: 0.3;"></i>
                    <p class="mt-2 mb-0 small">Chưa có tin nhắn nào</p>
                </div>`;
            return;
        }

        const html = contacts.map(c => {
            const date = new Date(c.lastSentAt);
            const timeStr = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });

            //Avatar 
            let avatarHtml;
            if (c.avatarUrl && c.avatarUrl.trim() !== "") {
                avatarHtml = `<img src="${c.avatarUrl}" class="avatar-img" alt="${escapeHtml(c.displayName)}">`;
            } else {
                const initial = '/images/avatars/default.png';
                avatarHtml = `<img src="${initial}" class="avatar-img" alt="${escapeHtml(c.displayName)}">`;
            }

            let previewText = c.lastMessagePreview || (c.unreadCount > 0 ? "Tin nhắn mới" : "Tin nhắn được bảo mật");
            const previewClass = c.unreadCount > 0 ? "fw-bold text-dark" : "text-muted";
            const isActive = currentConversationId === c.conversationId ? 'active' : '';
            const unreadBadge = c.unreadCount > 0 ? `<div class="unread-badge">${c.unreadCount}</div>` : '';

            return `
                <div class="contact-item d-flex align-items-center ${isActive}" 
                     id="contact-${c.userId}"
                     onclick="startChatWithUser('${c.userId}', '${c.username}', '${c.displayName}', '${c.conversationId}')">
                    <div class="avatar-container">${avatarHtml}</div>
                    <div class="flex-grow-1 overflow-hidden" style="min-width: 0;">
                        <div class="d-flex justify-content-between align-items-center">
                            <h6 class="mb-0 fw-semibold text-truncate">${escapeHtml(c.displayName)}</h6>
                        </div>
                        <div class="last-msg-preview ${previewClass} text-truncate">${escapeHtml(previewText)}</div>
                    </div>
                    ${unreadBadge}
                    <div class="contact-time">${timeStr}</div>
                </div>
            `;
        }).join('');
        container.innerHTML = html;
    }

    // ===== SEARCH LOGIC =====
    document.getElementById('searchUserInput').addEventListener('input', function(e) {
        const term = e.target.value.trim();
        document.getElementById('clearSearch').style.display = term.length > 0 ? 'block' : 'none';
        if (searchTimeout) clearTimeout(searchTimeout);

        if (term.length < 3) {
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('conversationList').style.display = 'block';
            return;
        }
        searchTimeout = setTimeout(() => searchUsers(term), 300);
    });

    document.getElementById('clearSearch').addEventListener('click', function() {
        document.getElementById('searchUserInput').value = '';
        document.getElementById('searchResults').style.display = 'none';
        document.getElementById('conversationList').style.display = 'block';
        this.style.display = 'none';
    });

    async function searchUsers(term) {
        try {
            const response = await fetch(`@Url.Action("SearchUsers", "Chat")?searchTerm=${encodeURIComponent(term)}`);
            if (response.ok) displaySearchResults(await response.json());
        } catch (e) {}
    }

    function displaySearchResults(users) {
        const resultsDiv = document.getElementById('searchResultsList');
        document.getElementById('searchCount').textContent = users.length;
        document.getElementById('searchResults').style.display = 'block';
        document.getElementById('conversationList').style.display = 'none';

        if (users.length === 0) {
            resultsDiv.innerHTML = '<div class="text-center py-4 text-muted">Không tìm thấy</div>';
            return;
        }

        resultsDiv.innerHTML = users.map(user => {
            // 1. Xử lý ảnh null hoặc rỗng
            const avatarSrc = user.avatarUrl && user.avatarUrl.trim() !== ''
                ? user.avatarUrl
                : '/images/avatars/default.png';

            return `
        <div class="user-item d-flex align-items-center mb-2 p-2 rounded cursor-pointer hover-bg" 
             onclick="startChatWithUser('${user.userId}', '${escapeHtml(user.username)}', '${escapeHtml(user.displayName)}')"
             style="transition: background 0.2s;">
            
            <div class="avatar-circle me-3" 
                 style="width: 45px; height: 45px; min-width: 45px; border-radius: 50%; overflow: hidden; background-color: #e4e6eb; border: 1px solid #dee2e6;">
                
                <img src="${avatarSrc}" 
                     alt="${escapeHtml(user.displayName)}"
                     style="width: 100%; height: 100%; object-fit: cover;"
                     onerror="this.onerror=null; this.src='/images/avatars/default.png';"/>
            </div>

            <div style="overflow: hidden;">
                <div class="fw-semibold text-truncate" style="font-size: 15px;">${escapeHtml(user.displayName)}</div>
                <small class="text-muted text-truncate d-block" style="font-size: 13px;">${escapeHtml(user.username)}</small>
            </div>
        </div>
    `}).join('');
    }

    // ===== DECRYPT LOGIC =====

    // ===== MAIN CHAT FUNCTIONS =====
    async function setupNewConversation(convId, partnerId, partnerPublicKey) {
        console.log("🛠 Đang khởi tạo khóa hội thoại mới...");

        // 1. Sinh AES Key ngẫu nhiên
        const newAesKey = generateRandomKey(32);

        // 2. Lấy Public Key của chính mình
        let myPublicKey = null;
        try {
            const myResp = await fetch(`@Url.Action("GetUserPublicKey", "Chat")?userId=${currentUserId}`);
            if (myResp.ok) myPublicKey = (await myResp.json()).publicKey;
        } catch(e) {}

        if (!myPublicKey || !partnerPublicKey) {
            alert("Không thể lấy Public Key để khởi tạo bảo mật.");
            return;
        }

        const encryptor = new JSEncrypt();

        // 3. Mã hóa Key cho MÌNH (dùng Public Key của mình)
        encryptor.setPublicKey(myPublicKey);
        const keyForMe = encryptor.encrypt(newAesKey);

        // 4. Mã hóa Key cho ĐỐI PHƯƠNG (dùng Public Key của họ)
        encryptor.setPublicKey(partnerPublicKey);
        const keyForPartner = encryptor.encrypt(newAesKey);

        // 5. Gửi cả 2 key lên server
        const payload = {
            conversationId: convId,
            keys: [
                { userId: currentUserId, encryptedKey: keyForMe },
                { userId: partnerId, encryptedKey: keyForPartner }
            ]
        };

        const resp = await fetch('/Chat/InitializeKeys', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'RequestVerificationToken': getToken()
            },
            body: JSON.stringify(payload)
        });

        if (resp.ok) {
            // Lưu ngay key gốc vào cache để dùng luôn
            conversationKeysCache.delete(convId);
            await getConversationKey(convId);            
            console.log("✅ Đã khởi tạo Conversation Key thành công!");
        } else {
            console.error("❌ Lỗi khởi tạo key trên server");
        }
}
    // async function startChatWithUser(userId, username, displayName, forceConversationÌd = null) {
    //     if (!currentUserId) return;
    //     showLoading('Đang tải chat...');
    //    
    //     // UI Update
    //     document.querySelectorAll('.contact-item').forEach(el => el.classList.remove('active'));
    //     const activeItem = document.getElementById(`contact-${userId}`);
    //     if(activeItem) {
    //         activeItem.classList.add('active');
    //         const badge = activeItem.querySelector('.unread-badge');
    //         if(badge) badge.remove();
    //     }
    //    
    //     try {
    //         // 1. Mark Read
    //         await markAsRead(userId);
    //        
    //         // 2. Get Public Key & Conv
    //         const keyResp = await fetch(`@Url.Action("GetUserPublicKey", "Chat")?userId=${userId}`);
    //         if (keyResp.ok) currentRecipientPublicKey = (await keyResp.json()).publicKey;
    //
    //         const convResp = await fetch(`@Url.Action("GetOrCreateConversation", "Chat")?recipientId=${userId}`, {
    //             method: 'POST',
    //             headers: { 'Content-Type': 'application/json', 'RequestVerificationToken': getToken() }
    //         });
    //         const convData = await convResp.json();
    //         currentConversationId = convData.conversationId;
    //         currentRecipientId = userId;
    //
    //         if (connection?.state === signalR.HubConnectionState.Connected) {
    //             await connection.invoke("JoinConversation", currentConversationId);
    //         }
    //        
    //         if (!convData.isKeyInitialized) {
    //             console.log("🆕 Chưa có key, đang khởi tạo...");
    //             if (currentRecipientPublicKey) {
    //                 await setupNewConversation(currentConversationId, userId, currentRecipientPublicKey);
    //             }
    //         }
    //         // Đảm bảo key đã được load vào cache
    //         await getConversationKey(currentConversationId);
    //
    //         const messages = await loadMessagesAndReturn(currentConversationId);
    //         await displayMessages(messages);
    //         showChatWindow(username, displayName);
    //         setTimeout(() => scrollToBottom(false), 100);
    //
    //     } catch (e) { console.error(e); }
    //     finally { hideLoading(); }
    // }

    // FIX: Thêm tham số forceConversationId (mặc định null)
    async function startChatWithUser(userId, username, displayName, forceConversationId = null) {
        if (!currentUserId) return;

        showLoading('Đang tải chat...');

        try {
            // 1. Mark Read
            await markAsRead(userId);

            // 2. Get Public Key (luôn lấy để phòng trường hợp cần thiết)
            try {
                const keyResp = await fetch(`@Url.Action("GetUserPublicKey", "Chat")?userId=${userId}`);
                if (keyResp.ok) currentRecipientPublicKey = (await keyResp.json()).publicKey;
            } catch(e) { console.warn("Không lấy được Public Key", e); }

            // ===== LOGIC QUAN TRỌNG ĐÃ SỬA =====
            if (forceConversationId) {
                // CASE 1: Bấm từ danh sách liên hệ (Đã biết rõ ID cuộc trò chuyện)
                console.log("📂 Mở cuộc trò chuyện cụ thể:", forceConversationId);
                currentConversationId = forceConversationId;
                currentRecipientId = userId;

                // UI Update: Highlight đúng dòng dựa trên Conversation ID
                document.querySelectorAll('.contact-item').forEach(el => el.classList.remove('active'));
                const activeItem = document.getElementById(`contact-${forceConversationId}`);
                if(activeItem) {
                    activeItem.classList.add('active');
                    const badge = activeItem.querySelector('.unread-badge');
                    if(badge) badge.remove();
                }

            } else {
                // CASE 2: Bấm từ Tìm kiếm (Chưa biết ID, nhờ Backend định đoạt)
                const convResp = await fetch(`@Url.Action("GetOrCreateConversation", "Chat")?recipientId=${userId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'RequestVerificationToken': getToken() }
                });

                if (!convResp.ok) {
                    const err = await convResp.json();
                    alert(err.message || "Không thể tạo cuộc trò chuyện.");
                    hideLoading();
                    return;
                }

                const convData = await convResp.json();
                currentConversationId = convData.conversationId;
                currentRecipientId = userId;

                // Nếu tạo mới hoàn toàn thì kiểm tra khởi tạo key
                if (!convData.isKeyInitialized) {
                    console.log("🆕 Chưa có key, đang khởi tạo...");
                    if (currentRecipientPublicKey) {
                        await setupNewConversation(currentConversationId, userId, currentRecipientPublicKey);
                    }
                }

                // UI Update: Highlight (nếu tìm thấy trong list contacts)
                document.querySelectorAll('.contact-item').forEach(el => el.classList.remove('active'));
                // Cố tìm theo conversationId mới lấy được
                const activeItem = document.getElementById(`contact-${currentConversationId}`);
                if(activeItem) activeItem.classList.add('active');
            }

            // 3. SignalR Join Group
            if (connection?.state === signalR.HubConnectionState.Connected) {
                await connection.invoke("JoinConversation", currentConversationId);
            }

            // 4. Lấy Key & Load tin nhắn
            // Quan trọng: getConversationKey sẽ lấy key của ĐÚNG conversationId hiện tại
            await getConversationKey(currentConversationId);

            const messages = await loadMessagesAndReturn(currentConversationId);
            await displayMessages(messages);
            showChatWindow(username, displayName);
            setTimeout(() => scrollToBottom(false), 100);

        } catch (e) {
            console.error(e);
            alert("Có lỗi xảy ra.");
        }
        finally { hideLoading(); }
    }
    
    async function markAsRead(senderId) {
        try {
            await fetch('@Url.Action("MarkRead", "Chat")', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'RequestVerificationToken': getToken() },
                body: JSON.stringify(senderId)
            });
            loadRecentContacts(); // Reload sidebar quietly
        } catch(e) {}
    }
    
// const resp = await fetch(`@Url.Action("GetMessages", "Chat")?conversationId=${convId}&count=20`);
    async function loadMessagesAndReturn(convId, beforeId = null) {
        try {
            let url = `@Url.Action("GetMessages", "Chat")?conversationId=${convId}&count=20`;
            if(beforeId){
                url += `&beforeId=${beforeId}`;
            }
            const resp = await fetch(url);
            if(resp.ok) {
                const messages = await resp.json();
                if (messages.length <20) {
                    isAllLoaded = true;
                }
                
                if (messages.length > 0) {
                    oldestMessageId = messages[0].messageId;
                }
                return messages;
            }
            return [];
        } catch { return []; }
    }
    //isHistory = true (chèn lên đầu), false (load mới)
    async function displayMessages(messages, isHistory = false) {
        const area = document.getElementById('messagesArea');
        const visibleMessages = messages.filter(msg => !msg.pinExchange);

        if (visibleMessages.length === 0) {
            if (!isHistory && area.innerHTML === '') {
                area.innerHTML = '<div class="text-center py-4 text-muted"><p>Chưa có tin nhắn</p></div>';
            }
            return;
        }

        const myPinLocal = getMyPin();
        let html = ''

        for (const msg of visibleMessages) {
            let content = msg.cipherText;
            let isFile = msg.messageType !== 0;
            let decryptedText = null;

            try {
                let convKey = await getConversationKey(msg.conversationId);
                if (convKey) {
                    decryptedText = await AesGcmHelper.decrypt(msg.cipherText, convKey);
                    if (decryptedText) {
                        if (isFile) {
                            if (msg.attachment) {
                                content = renderFileAttachment(decryptedText, msg.attachment, msg.messageType);
                            } else {
                                content = `<a href="${decryptedText}" target="_blank" class="text-white">📎 File đính kèm</a>`;
                            }
                        } else {
                            content = escapeHtml(decryptedText);
                        }
                    } else {
                        content = '[Lỗi giải mã hoặc tin nhắn bị giả mạo]';
                    }
                } else {
                    content = '[Đang tải khóa...]';
                    convKey = getConversationKey(msg.conversationId)
                }
            } catch (e) {
                content = '[Lỗi dữ liệu]';
            }

            const isMine = msg.isMine;
            const bubbleClass = isMine ? 'message-mine' : 'message-theirs';
            const time = formatTime(msg.createdAt);

            if (isMine) {
                // Tin nhắn của mình: nút dropdown ở bên TRÁI (trước bubble)
                html += `
            <div class="message ${bubbleClass}" id="msg-${msg.messageId}">
                <!-- Dropdown Button - Bên trái cho tin nhắn của mình -->
                <div class="dropdown">
                    <button class="message-actions-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <ul class="dropdown-menu message-dropdown-menu">
                        <li>
                            <a class="dropdown-item message-dropdown-item delete" onclick="handleDeleteMessage('${msg.messageId}')">
                                <i class="bi bi-trash text-danger"></i>
                                <span>Xóa tin nhắn</span>
                            </a>
                        </li>
                        <li>
                            <a class="dropdown-item message-dropdown-item report" onclick="handleReportMessage('${msg.messageId}')">
                                <i class="bi bi-flag text-warning"></i>
                                <span>Báo cáo tin nhắn</span>
                            </a>
                        </li>
                    </ul>
                </div>
                
                <!-- Message Content -->
                <div class="message-content">
                    <div class="message-bubble">${content}</div>
                    <div class="message-time">${time}</div>
                </div>
            </div>
        `;
            } else {
                // Tin nhắn của người khác: nút dropdown ở bên PHẢI (sau bubble)
                html += `
            <div class="message ${bubbleClass}" id="msg-${msg.messageId}">
                <!-- Message Content -->
                <div class="message-content">
                    <div class="message-bubble">${content}</div>
                    <div class="message-time">${time}</div>
                </div>
                
                <!-- Dropdown Button - Bên phải cho tin nhắn người khác -->
                <div class="dropdown">
                    <button class="message-actions-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <ul class="dropdown-menu message-dropdown-menu">
                        <li>
                            <a class="dropdown-item message-dropdown-item report" onclick="handleReportMessage('${msg.messageId}')">
                                <i class="bi bi-flag text-warning"></i>
                                <span>Báo cáo tin nhắn</span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        `;
            }
        }

        if (isHistory) {
            const oldHeight = area.scrollHeight;
            const oldTop = area.scrollTop;

            area.insertAdjacentHTML('afterbegin', html);

            area.scrollTop = area.scrollHeight - oldHeight + oldTop;
        } else {
            area.innerHTML = html;
            scrollToBottom(false);
        }
}

    // Hàm cắt chuỗi giờ: Bất chấp múi giờ, bất chấp trình duyệt
    function formatTime(dateInput) {
        if (!dateInput) return '';
        const str = String(dateInput);
        const match = str.match(/T(\d{2}:\d{2})/);

        if (match) {
            return match[1];
        }

        // Fallback: Nếu định dạng lạ không có chữ T, thử parse kiểu cũ
        try {
            const date = new Date(str);
            // Ép về giờ 2 số và phút 2 số
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        } catch {
            return '';
        }
    }
    
    function showChatWindow(username, displayName) {
        document.getElementById('welcomeScreen').style.display = 'none';
        document.getElementById('chatWindow').style.display = 'flex';

        const elDisplayName = document.getElementById('chatDisplayName');
        if(elDisplayName) elDisplayName.textContent = displayName;

        const elUsername = document.getElementById('chatUsername');
        if(elUsername) elUsername.textContent = username;

        const elWelcome = document.getElementById('welcomeName');
        if(elWelcome) elWelcome.textContent = displayName;

        const input = document.getElementById('messageInput');
        const btn = document.getElementById('sendBtn');
        if(input) { input.disabled = false; input.focus(); }
        if(btn) btn.disabled = false;
    }

    // ===== UI HELPERS (TYPING) =====
    function showTypingIndicator() {
        const area = document.getElementById('messagesArea');
        if (document.getElementById('typingIndicator')) return;

        const div = document.createElement('div');
        div.id = 'typingIndicator';
        div.className = 'message message-theirs';
        div.innerHTML = `
            <div class="message-bubble bg-light text-secondary">
                <div class="typing-dots">
                    <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                </div>
            </div>`;
        area.appendChild(div);
        area.scrollTop = area.scrollHeight;
    }

    function hideTypingIndicator() {
        const el = document.getElementById('typingIndicator');
        if (el) el.remove();
    }

    // ===== HELPER: APPEND MESSAGE (SMOOTH UX) =====
    async function appendSingleMessageToUI(msg) {
        console.log("🔨 appendSingleMessageToUI called:", {
            messageId: msg.messageId,
            messageType: msg.messageType,
            hasAttachment: !!msg.attachment,
            attachment: msg.attachment
        });

        let content = msg.cipherText;
        let isFile = msg.messageType !== 0;
        try {
            let convKey = await getConversationKey(msg.conversationId);
            console.log("🔑 ConvKey available");

            if (convKey) {
                const decryptedData = await AesGcmHelper.decrypt(msg.cipherText, convKey);

                if (decryptedData) {
                    if (isFile) {
                        console.log("🔓 Decrypted URL length:", decryptedData.length);

                        if (msg.attachment) {
                            console.log("✅ Rendering with attachment data");
                            content = renderFileAttachment(decryptedData, msg.attachment, msg.messageType);
                        } else {
                            console.log("⚠️ No attachment data, using placeholder");
                            content = createFileAttachmentPlaceholder(decryptedData, msg.messageType);
                        }
                    } else {
                        content = escapeHtml(decryptedData);
                    }
                } else {
                    console.error("❌ Decryption returned null (Wrong PIN or Integrity check failed)");
                    content = '[Lỗi giải mã hoặc sai mã PIN]';
                }

            } else {
                content = '[Đang tải khóa...]';
                loadMessagesAndReturn(currentConversationId).then(displayMessages);
            }
        } catch (e) {
            console.error('❌ Append UI Error:', e);
            content = '[Lỗi hiển thị]';
        }

        const area = document.getElementById('messagesArea');
        const isMine = msg.senderId === currentUserId;
        const messageClass = isMine ? 'message-mine' : 'message-theirs';
        const time = formatTime(msg.createdAt);

        let html = '';

        if (isMine) {
            // Tin nhắn của mình: dropdown bên TRÁI
            html = `
            <div class="message ${messageClass}" id="msg-${msg.messageId}">
                <!-- Dropdown Button - Bên trái -->
                <div class="dropdown">
                    <button class="message-actions-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <ul class="dropdown-menu message-dropdown-menu">
                        <li>
                            <a class="dropdown-item message-dropdown-item delete" onclick="handleDeleteMessage('${msg.messageId}')">
                                <i class="bi bi-trash text-danger"></i>
                                <span>Xóa tin nhắn</span>
                            </a>
                        </li>
                        <li>
                            <a class="dropdown-item message-dropdown-item report" onclick="handleReportMessage('${msg.messageId}')">
                                <i class="bi bi-flag text-warning"></i>
                                <span>Báo cáo tin nhắn</span>
                            </a>
                        </li>
                    </ul>
                </div>
                
                <!-- Message Content -->
                <div class="message-content">
                    <div class="message-bubble">${content}</div>
                    <div class="message-time">${time}</div>
                </div>
            </div>
        `;
        } else {
            // Tin nhắn của người khác: dropdown bên PHẢI
            html = `
            <div class="message ${messageClass}" id="msg-${msg.messageId}">
                <!-- Message Content -->
                <div class="message-content">
                    <div class="message-bubble">${content}</div>
                    <div class="message-time">${time}</div>
                </div>
                
                <!-- Dropdown Button - Bên phải -->
                <div class="dropdown">
                    <button class="message-actions-btn" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <ul class="dropdown-menu message-dropdown-menu">
                        <li>
                            <a class="dropdown-item message-dropdown-item report" onclick="handleReportMessage('${msg.messageId}')">
                                <i class="bi bi-flag text-warning"></i>
                                <span>Báo cáo tin nhắn</span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        `;
        }

        area.innerHTML += html;

        console.log("✅ Message appended to UI");

        // Remove typing indicator
        hideTypingIndicator();

        // Scroll to bottom
        scrollToBottom(true);
    }
    // ===== SIGNALR EVENTS =====
    async function initializeSignalR() {
        connection = new signalR.HubConnectionBuilder().withUrl("/chatHub").withAutomaticReconnect().build();

        connection.on("ReceiveMessage", async (msg) => {
            console.log("📨 ReceiveMessage event:", msg); // Debug log

            // Update contact list nếu tin nhắn không phải của mình
            if (msg.senderId !== currentUserId) {
                await loadRecentContacts();
            }

            // Chỉ xử lý nếu đang ở đúng conversation
            if (msg.conversationId === currentConversationId) {
                console.log("✅ Message for current conversation"); // Debug log

                // Mark as read nếu là tin nhắn của người khác
                if (msg.senderId !== currentUserId) {
                    await markAsRead(msg.senderId);
                }

                // Append message to UI
                await appendSingleMessageToUI(msg);
            } else {
                console.log("⏭️ Message for different conversation"); // Debug log
            }
        });
        connection.on("UpdateContactList", async () => {
            console.log("Received UpdateContactList signal");
            await loadRecentContacts();
        });

        connection.on("UserTyping", (data) => {
            if (data.conversationId === currentConversationId && data.userId !== currentUserId) showTypingIndicator();
        });

        connection.on("UserStoppedTyping", (data) => {
            if (data.conversationId === currentConversationId && data.userId !== currentUserId) hideTypingIndicator();
        });

        try { await connection.start(); console.log("SignalR Connected"); } catch(e) {}
    }

    // ===== SENDING =====
    document.getElementById('messageInput').addEventListener('input', () => {
        if (!currentConversationId || !connection) return;
        if (typingTimeout) clearTimeout(typingTimeout);
        connection.invoke("UserTyping", currentConversationId).catch(console.error);
        typingTimeout = setTimeout(() => {
            connection.invoke("UserStoppedTyping", currentConversationId).catch(console.error);
        }, 2000);
    });

    document.getElementById('messageForm').addEventListener('submit', async function(e) {
        e.preventDefault();
        if (!currentConversationId || !connection) return;

        const input = document.getElementById('messageInput');
        const text = input.value.trim();
        const filesToSend = [...selectedFiles]; //copy mảng
        
        //reset UI
        input.value = '';
        input.style.height = 'auto';
        
        if (filesToSend.length > 0) {
            selectedFiles = []; 
            document.getElementById('fileInput').value = '';
            // document.getElementById('filePreview').classList.add('d-none');
        }
        //Text
        if (text) {
            try {
                const convKey = conversationKeysCache.get(currentConversationId);
                if (!convKey) {
                    alert("Chưa có khóa bảo mật. Vui lòng tải lại trang.");
                    return;
                }
                const encrypted = await AesGcmHelper.encrypt(text, convKey);
                
                await connection.invoke("SendMessage", {
                    conversationId: currentConversationId,
                    cipherText: encrypted,
                    messageType: 0
                });

                input.value = '';
                
            }catch (err) {console.error("Lỗi gửi text:", err);}
        }
        if (filesToSend.length > 0) {
            for (const file of filesToSend) {
                await handleFileUpload(file);
            }
            input.focus();
        }
        const searchInput = document.getElementById('searchUserInput');
        if (searchInput.value.trim() !== "") {
            searchInput.value = '';
            document.getElementById('clearSearch').style.display = 'none';

            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('conversationList').style.display = 'block';
            await loadRecentContacts();

            //autoclick
            const contactElementId = `contact-${currentRecipientId}`;
            const contactElement = document.getElementById(contactElementId);
            if (contactElement) {
                contactElement.click();
                contactElement.scrollIntoView({behavior: 'smooth', block: 'nearest'});
            }
        }
    });
    document.getElementById('attachFileBtn').addEventListener('click', function() {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', function(e) {
        selectedFiles = Array.from(e.target.files);        
        document.getElementById('messageInput').focus();
        if (selectedFiles.length > 0) {
            document.getElementById("filePreview").hidden = false;
            displayFilePreview(selectedFiles);
        }
        else{
            document.getElementById("filePreview").hidden = true;
        }
    });
    document.getElementById('removeFileBtn').addEventListener('click', function() {
        selectedFiles = [];
        document.getElementById('fileInput').value = '';
        document.getElementById('filePreview').classList.add('d-none');
    });

    //Auto-resize textarea
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    //Enter để gửi (cả text và file), Shift+Enter để xuống dòng
    messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('messageForm').dispatchEvent(new Event('submit'));
        }
    });
    // ===== File Upload + review =====
    function displayFilePreview(files) {
        const preview = document.getElementById('filePreview');
        const fileNameLabel = document.getElementById('fileName');
        const fileSizeLabel = document.getElementById('fileSize');
        const fileIcon = document.getElementById('fileIcon');
        
        let totalSize = 0;
        files.forEach(f => totalSize += f.size);

        // Hiển thị tên
        if (files.length === 1) {
            fileNameLabel.textContent = files[0].name;
            // Đổi icon theo file đầu tiên
            updateFileIcon(files[0].name, fileIcon);
        } else {
            fileNameLabel.textContent = `${files.length} files: ${files[0].name} ...`;
            fileIcon.className = `bi bi-files fs-3 text-primary me-2`; // Icon folder/multiple
        }

        fileSizeLabel.textContent = formatFileSize(totalSize);
        preview.classList.remove('d-none');
    }

    //Helpẻ đổi icon
    function updateFileIcon(fileName, iconElement) {
        const ext = fileName.split('.').pop().toLowerCase();
        let iconClass = 'bi-file-earmark';
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(ext)) iconClass = 'bi-file-earmark-image';
        else if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'].includes(ext)) iconClass = 'bi-file-earmark-play';
        else if (['pdf'].includes(ext)) iconClass = 'bi-file-earmark-pdf';
        else if (['doc', 'docx'].includes(ext)) iconClass = 'bi-file-earmark-word';
        else if (['xls', 'xlsx'].includes(ext)) iconClass = 'bi-file-earmark-excel';
        else if (['zip', 'rar'].includes(ext)) iconClass = 'bi-file-earmark-zip';
        iconElement.className = `bi ${iconClass} fs-3 text-primary me-2`;
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    async function handleFileUpload(file) {
        if (!currentConversationId || !connection) {
            console.error("❌ No conversation or connection");
            return;
        }

        const convKey = conversationKeysCache.get(currentConversationId);
        if (!convKey) { alert('Lỗi Key'); return; }

        try {
            console.log("📤 Starting file upload..."); // Debug log

            const progressBar = document.querySelector('#uploadProgress .progress-bar');
            document.getElementById('uploadProgress').style.display = 'block';
            progressBar.style.width = '0%';

            // 1. Upload file
            const formData = new FormData();
            formData.append('file', file);
            formData.append('conversationId', currentConversationId);

            progressBar.style.width = '30%';

            const uploadResponse = await fetch('@Url.Action("UploadFile", "Chat")', {
                method: 'POST',
                headers: {
                    'RequestVerificationToken': getToken()
                },
                body: formData
            });

            progressBar.style.width = '60%';

            if (!uploadResponse.ok) {
                const error = await uploadResponse.json();
                alert('Lỗi upload: ' + (error.message || 'Unknown error'));
                document.getElementById('uploadProgress').style.display = 'none';
                return;
            }

            const uploadResult = await uploadResponse.json();
            console.log("✅ Upload result:", uploadResult); // Debug log

            progressBar.style.width = '80%';

            // 2. Mã hóa URL
            const encryptedUrl = await AesGcmHelper.encrypt(uploadResult.url, convKey);            
            // 3. Update message
            const updateResponse = await fetch('@Url.Action("UpdateMessageWithFile", "Chat")', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': getToken()
                },
                body: JSON.stringify({
                    messageId: uploadResult.messageId,
                    encryptedUrl: encryptedUrl
                })
            });

            if (!updateResponse.ok) {
                alert('Lỗi cập nhật tin nhắn');
                document.getElementById('uploadProgress').style.display = 'none';
                return;
            }

            progressBar.style.width = '100%';

            // 4. ✅ FIX: Xác định messageType ĐÚNG dựa trên resourceType từ server
            let messageType = 3; // Default: File

            const resourceType = (uploadResult.resourceType || '').toLowerCase();
            console.log("🔍 Resource type from server:", resourceType); // Debug

            if (resourceType === 'image') {
                messageType = 1; // Image
            } else if (resourceType === 'video') {
                messageType = 2; // Video
            }

            console.log("✅ Final messageType:", messageType); // Debug

            const signalRData = {
                conversationId: currentConversationId,
                messageId: uploadResult.messageId,
                cipherText: encryptedUrl,
                messageType: messageType,
                attachment: {
                    url: encryptedUrl,
                    fileName: uploadResult.fileName,
                    resourceType: uploadResult.resourceType,
                    format: uploadResult.format
                }
            };

            console.log("📡 Sending via SignalR:", signalRData); // Debug log

            await connection.invoke("SendFileMessage", signalRData);

            console.log("✅ File message sent successfully"); // Debug log

            // Reset UI
            selectedFile = null;
            document.getElementById('fileInput').value = '';
            document.getElementById('filePreview').classList.add('d-none');

            setTimeout(() => {
                document.getElementById('uploadProgress').style.display = 'none';
            }, 500);

        } catch (error) {
            console.error('❌ File upload error:', error);
            alert('Lỗi khi upload file: ' + error.message);
            document.getElementById('uploadProgress').style.display = 'none';
        }
}
    function createFileAttachmentPlaceholder(url, messageType) {
        console.log("🖼️ Creating placeholder for type:", messageType);

        if (messageType === 1) {
            // Image với fallback
            return `
        <div class="file-attachment">
            <div style="position: relative; max-width: 300px; max-height: 300px;">
                <img src="${url}" alt="Image" 
                     style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer;"
                     onclick="window.open('${url}', '_blank')"
                     onerror="this.onerror=null; this.src='${FALLBACK_IMAGE}';"/>
                <!-- Loading overlay -->
                <div class="image-loading-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.8); display: flex; align-items: center; justify-content: center; border-radius: 8px;">
                    <div class="text-center">
                        <div class="spinner-border spinner-border-sm text-primary mb-1"></div>
                        <div class="small text-muted">Đang tải ảnh...</div>
                    </div>
                </div>
            </div>
        </div>
    `;
        } else if (messageType === 2) {
            // Video với fallback
            return `
        <div class="file-attachment">
            <div style="position: relative; max-width: 300px;">
                <video controls style="width: 100%; border-radius: 8px; background: #000;"
                       poster="${FALLBACK_IMAGE}">
                    <source src="${url}">
                    <!-- Fallback message -->
                    <div class="video-error text-center p-4 text-white" style="background: rgba(0,0,0,0.5);">
                        <i class="bi bi-exclamation-triangle fs-2"></i>
                        <div class="mt-2">Không thể tải video</div>
                    </div>
                </video>
            </div>
        </div>
    `;
        } else {
            // Other file với fallback UI
            return `
        <div class="file-attachment">
            <div class="file-placeholder d-flex align-items-center p-2 rounded" 
                 style="background: rgba(0,0,0,0.05); cursor: pointer;"
                 onclick="window.open('${url}', '_blank')">
                <div class="file-icon-container position-relative me-2">
                    <i class="bi bi-file-earmark fs-3 text-primary"></i>
                    <!-- Fallback icon nếu không tải được -->
                    <div class="fallback-indicator" style="position: absolute; top: -5px; right: -5px; width: 16px; height: 16px; border-radius: 50%; background: #ffc107; display: none; align-items: center; justify-content: center;">
                        <i class="bi bi-exclamation text-white" style="font-size: 10px;"></i>
                    </div>
                </div>
                <div class="flex-grow-1">
                    <div class="fw-semibold">File đính kèm</div>
                    <div class="small opacity-75">Click để tải</div>
                </div>
            </div>
        </div>
    `;
        }
    }

    function renderFileAttachment(url, attachment, messageType) {
        console.log("🎨 Rendering file attachment:", {
            url: url.substring(0, 50) + '...',
            fileName: attachment.fileName,
            messageType: messageType
        });

        const fileName = attachment.fileName || 'File';

        // Image
        if (messageType === 1) {
            return `
        <div class="file-attachment">
            <img src="${url}" alt="${escapeHtml(fileName)}" 
                 style="max-width: 300px; max-height: 300px; border-radius: 8px; cursor: pointer;"
                 onclick="window.open('${url}', '_blank')"
                 onerror="this.onerror=null; this.src='${FALLBACK_IMAGE}';"/>
        </div>
    `;
        }

        // Video
        if (messageType === 2) {
            return `
        <div class="file-attachment">
            <video controls style="max-width: 300px; border-radius: 8px;"
                   poster="${FALLBACK_IMAGE}" <!-- Thêm poster fallback -->
                   onerror="this.style.display='none'; this.parentElement.innerHTML='<div class=\'text-center p-3 bg-light rounded\'><i class=\'bi bi-file-earmark-x text-muted fs-3\'></i><div class=\'small mt-2\'>Không thể tải video</div></div>';">
                <source src="${url}" type="video/${attachment.format || 'mp4'}">
                <!-- Fallback nếu trình duyệt không hỗ trợ -->
                <div class="video-fallback text-center p-3">
                    <img src="${FALLBACK_IMAGE}" alt="Video không thể phát" style="max-width: 200px; opacity: 0.7;">
                    <div class="small mt-2">Trình duyệt không hỗ trợ video hoặc video bị lỗi</div>
                </div>
            </video>
            <div class="small mt-1 opacity-75">${escapeHtml(fileName)}</div>
        </div>
    `;
        }

        // Other files
        const ext = attachment.format || 'file';
        let iconClass = 'bi-file-earmark';

        if (['pdf'].includes(ext.toLowerCase())) {
            iconClass = 'bi-file-earmark-pdf';
        } else if (['doc', 'docx'].includes(ext.toLowerCase())) {
            iconClass = 'bi-file-earmark-word';
        } else if (['xls', 'xlsx'].includes(ext.toLowerCase())) {
            iconClass = 'bi-file-earmark-excel';
        } else if (['zip', 'rar'].includes(ext.toLowerCase())) {
            iconClass = 'bi-file-earmark-zip';
        }

        return `
        <div class="file-attachment">
            <a href="${url}" target="_blank" 
               class="text-decoration-none text-inherit d-flex align-items-center p-2 rounded" 
               style="background: rgba(0,0,0,0.05);"
               onclick="if(!this.getAttribute('href')) return false;">
                <i class="bi ${iconClass} fs-4 me-2"></i>
                <div>
                    <div class="fw-semibold">${escapeHtml(fileName)}</div>
                    <div class="small opacity-75">${ext.toUpperCase()}</div>
                </div>
            </a>
        </div>
    `;
    }
    // ==== Scroll (pagination) ====
    document.getElementById('messagesArea').addEventListener('scroll', async function() {
        const area = this;

        // Nếu cuộn lên sát đỉnh (còn 50px) VÀ chưa tải hết VÀ không đang bận tải VÀ đã có ID cũ nhất
        if (area.scrollTop < 50 && !isAllLoaded && !isLoadingHistory && oldestMessageId) {

            console.log("📥 Loading history...", oldestMessageId);
            isLoadingHistory = true;

            // 1. Tạo Spinner loading
            const loaderId = 'history-loader';
            let loader = document.getElementById(loaderId);
            if (!loader) {
                loader = document.createElement('div');
                loader.id = loaderId;
                loader.className = 'text-center p-2 small text-muted';
                loader.innerHTML = '<div class="spinner-border spinner-border-sm text-primary"></div> Đang tải tin cũ...';
                area.prepend(loader); // Chèn lên đỉnh
            }
            try{
                const messages = await loadMessagesAndReturn(currentConversationId, oldestMessageId);
                if (loader) loader.remove();
                if (messages.length > 0) {
                    await displayMessages(messages, true);
                } else {
                    isAllLoaded = true;
                }

            }catch(error){
                console.error("Lỗi tải lịch sử:", error);
                if (loader) loader.remove();
            }
            finally {
                isLoadingHistory = false;
            }
        }
    });
    // ===== INIT =====
    window.addEventListener('load', async () => {
        if (await autoVerifyPin() && await loadCurrentUserInfo()) {
            await initializeSignalR();
            await loadRecentContacts();
        }
    });
</script>
 }